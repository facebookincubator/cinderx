--- Test Suite Name ---
InlinerStaticTest
--- Passes ---
InlineFunctionCalls
Simplify
--- Test Name ---
InvokeStaticFunctionWithNoArgs
--- Input ---
def foo():
    # Chosen by fair dice roll. Guaranteed to be random.
    return 4

def test():
    return foo()
--- Expected ---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v2:MortalFunc[function:0xdeadbeef] = LoadConst<MortalFunc[function:0xdeadbeef]>
    BeginInlinedFunction<jittestmodule:foo> {
      NextInstrOffset 4
    }
    Snapshot
    v6:ImmortalLongExact[4] = LoadConst<ImmortalLongExact[4]>
    EndInlinedFunction
    Snapshot
    Return v6
  }
}
--- Test Name ---
InvokeStaticFunctionWithArgs
--- Input ---
def foo(x: int, y: int) -> int:
    # Chosen by fair dice roll. Guaranteed to be random.
    return x + y

def test():
    return foo(1, 2)
--- Expected ---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v4:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v5:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v6:MortalFunc[function:0xdeadbeef] = LoadConst<MortalFunc[function:0xdeadbeef]>
    BeginInlinedFunction<jittestmodule:foo> {
      NextInstrOffset 8
    }
    Snapshot
    UseType<LongExact> v4
    UseType<LongExact> v5
    UseType<ImmortalLongExact[1]> v4
    UseType<ImmortalLongExact[2]> v5
    v22:ImmortalLongExact[3] = LoadConst<ImmortalLongExact[3]>
    Snapshot
    Snapshot
    EndInlinedFunction
    Snapshot
    Return v22
  }
}
--- Test Name ---
InvokeStaticFunctionReturningCType
--- Input ---
from __static__ import int8

def foo() -> int8:
    # Chosen by fair dice roll. Guaranteed to be random.
    return 4

def test() -> int8:
    return foo()
--- Expected ---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v2:MortalFunc[function:0xdeadbeef] = LoadConst<MortalFunc[function:0xdeadbeef]>
    BeginInlinedFunction<jittestmodule:foo> {
      NextInstrOffset 4
    }
    Snapshot
    v6:CInt8[4] = LoadConst<CInt8[4]>
    EndInlinedFunction
    Snapshot
    Return<CInt8> v6
  }
}
--- Test Name ---
CalleeWithNonPrimitiveReturnHasObjectReturnType
--- Input ---
def foo(x) -> bool:
    # isinstance is typed by SP as returning bool but returns object in the
    # JIT.
    return isinstance(x, bool)

def test(x):
    return foo(x)
--- Expected ---
fun jittestmodule:test {
  bb 0 {
    v3:Object = LoadArg<0; "x">
    Snapshot
    v5:MortalFunc[function:0xdeadbeef] = LoadConst<MortalFunc[function:0xdeadbeef]>
    BeginInlinedFunction<jittestmodule:foo> {
      NextInstrOffset 6
      Locals<1> v3
    }
    Snapshot
    v13:OptObject = LoadGlobalCached<0; "isinstance">
    v14:MortalObjectUser[builtin_function_or_method:isinstance:0xdeadbeef] = GuardIs<0xdeadbeef> v13 {
      Descr 'LOAD_GLOBAL: isinstance'
    }
    Snapshot
    v16:OptObject = LoadGlobalCached<1; "bool">
    v17:ImmortalTypeExact[bool:obj] = GuardIs<0xdeadbeef> v16 {
      Descr 'LOAD_GLOBAL: bool'
    }
    Snapshot
    v21:Type = LoadField<ob_type@8, Type, borrowed> v3
    v22:CBool = PrimitiveCompare<Equal> v21 v17
    CondBranch<4, 5> v22
  }

  bb 4 (preds 0) {
    v23:Bool = PrimitiveBoxBool v22
    Branch<6>
  }

  bb 5 (preds 0) {
    v24:CInt32 = IsInstance v3 v17 {
      FrameState {
        NextInstrOffset 8
        Locals<1> v3
      }
    }
    v25:CInt32[1] = LoadConst<CInt32[1]>
    v26:CBool = PrimitiveCompare<Equal> v24 v25
    v27:Bool = PrimitiveBoxBool v26
    Branch<6>
  }

  bb 6 (preds 4, 5) {
    v28:Bool = Phi<4, 5> v23 v27
    Snapshot
    EndInlinedFunction
    Snapshot
    Return v28
  }
}
--- End ---
