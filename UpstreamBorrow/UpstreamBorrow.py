# Copyright (c) Meta Platforms, Inc. and affiliates.

# pyre-strict
import json
import os
import re
import subprocess
from collections import defaultdict
from dataclasses import dataclass
from functools import partial
from typing import Callable

import click

from clang.cindex import CursorKind

from .clang_parser import FileParser, ParsedFile

BORROW_CPP_DIRECTIVES_PATTERN: re.Pattern[str] = re.compile(
    r".*// @Borrow CPP directives from (\S+)"
)
BORROW_CPP_DIRECTIVES_NOINCLUDE_PATTERN: re.Pattern[str] = re.compile(
    r".*// @Borrow CPP directives noinclude from (\S+)"
)
BORROW_DECL_PATTERN: re.Pattern[str] = re.compile(
    r"// @Borrow (function|typedef|var) (\S+) from (\S+)"
)
CPP_DIRECTIVE_PATTERN: re.Pattern[str] = re.compile(
    r"#\s*(define|undef|if|elif|else|endif|include)"
)

HEADER = """// Auto-generated by UpstreamBorrow.py.
// See the Buck target fbcode//cinderx/UpstreamBorrow:gen_borrowed.c.

"""


def extract_preprocessor_directives(
    parsed_file: ParsedFile, includes: bool = True
) -> list[str]:
    print(f"Extracting preprocessor directives from: {parsed_file.source_file}")

    directives = []
    continuation = False
    for line in parsed_file.lines:
        line = line.rstrip()
        if continuation:
            directives.append(line)
            continuation = line.endswith("\\")
        elif m := re.match(CPP_DIRECTIVE_PATTERN, line):
            if includes or not m.group(1) == "include":
                directives.append(line)
                continuation = line.endswith("\\")
            else:
                continuation = False
        else:
            continuation = False

    return directives


@dataclass
class Decl:
    kind: CursorKind
    name: str
    source_file: str


@dataclass
class CppDirective:
    source_file: str
    includes: bool


def parse_borrow_info(input_string: str) -> Decl | None:
    match = BORROW_DECL_PATTERN.match(input_string)
    if not match:
        return None

    kind_str = match.group(1)
    name = match.group(2)
    source_file = match.group(3)

    if kind_str == "function":
        # pyre-ignore[16]: `CursorKind` has no attribute `FUNCTION_DECL`.
        kind = CursorKind.FUNCTION_DECL
    elif kind_str == "typedef":
        # pyre-ignore[16]: `CursorKind` has no attribute `TYPEDEF_DECL`.
        kind = CursorKind.TYPEDEF_DECL
    elif kind_str == "var":
        # pyre-ignore[16]: `CursorKind` has no attribute `VAR_DECL`.
        kind = CursorKind.VAR_DECL
    elif kind_str == "enum":
        # pyre-ignore[16]: `CursorKind` has no attribute `ENUM_DECL`.
        kind = CursorKind.ENUM_DECL
    else:
        raise Exception(f"Unknown kind: {kind_str}")

    return Decl(kind, name, source_file)


class TemplateFileProcessor:
    input_filename: str
    output_filename: str
    file_parser: FileParser
    version: str
    input_lines: list[str | Decl | CppDirective]
    needed: dict[str, dict[CursorKind, set[str]]]
    decls: dict[str, dict[str, list[str]]]
    output_lines: list[str]

    def __init__(
        self,
        input_filename: str,
        output_filename: str,
        file_parser: FileParser,
        version: str,
    ) -> None:
        self.input_filename = input_filename
        self.output_filename = output_filename
        self.file_parser = file_parser
        self.version = version
        self.input_lines = []
        self.output_lines = []
        # pyre-ignore[8]: Incompatible attribute type
        self.needed = defaultdict(lambda: defaultdict(set))
        self.decls = defaultdict(dict)

    def _read_input_file(self) -> None:
        """Read the input file and parse borrow directives."""

        with open(self.input_filename, "r") as f:
            input_lines = f.readlines()

        for line in input_lines:
            line = line.rstrip()

            if match := parse_borrow_info(line):
                self.input_lines.append(match)

            elif match := BORROW_CPP_DIRECTIVES_PATTERN.match(line):
                source_file = match.group(1)
                d = CppDirective(source_file, includes=True)
                self.input_lines.append(d)

            elif match := BORROW_CPP_DIRECTIVES_NOINCLUDE_PATTERN.match(line):
                source_file = match.group(1)
                d = CppDirective(source_file, includes=False)
                self.input_lines.append(d)

            else:
                self.input_lines.append(line)

    def _process_directives(self) -> None:
        """Process borrow directives and group required actions."""
        for line in self.input_lines:
            match line:
                case Decl() as d:
                    self.needed[d.source_file][d.kind].add(d.name)
                case CppDirective() as d:
                    # We don't need to do anything here, we extract these in
                    # generate_output directly since they are done only once
                    # per file with all the directives extracted in a block.
                    pass
                case str():
                    # Catch malformed borrow directives
                    if line.startswith("// @Borrow"):
                        raise RuntimeError(f"@Borrow not processed: {line}")

    def _extract_decls(self) -> None:
        for source_file, needed_decls in self.needed.items():
            parsed_file = self.file_parser.parse(source_file)
            # We only need to look for symbols at top level.
            for cursor in parsed_file.translation_unit.cursor.get_children():
                name = cursor.spelling
                if name in needed_decls.get(cursor.kind, ()):
                    if extent := cursor.extent:
                        # We always extract complete lines
                        content = parsed_file.lines[
                            extent.start.line - 1 : extent.end.line
                        ]
                        # Overwrite earlier declarations; the last one is the
                        # function definition.
                        # pyre-fixme[6]: For 2nd argument expected `List[str]` but
                        #  got `str`.
                        self.decls[source_file][name] = content

    def _generate_output(self) -> None:
        out = []
        for line in self.input_lines:
            match line:
                case Decl(kind, name, source_file):
                    lines = self.decls[source_file][name]
                    if not lines:
                        raise RuntimeError(
                            f"Could not find {kind} for '{name}' in {source_file}"
                        )
                    out.extend(lines)
                case CppDirective(source_file, includes):
                    parsed_file = self.file_parser.parse(source_file)
                    lines = extract_preprocessor_directives(parsed_file, includes)
                    out.extend(lines)
                case str():
                    out.append(line)
        self.output_lines = out

    def _write_output_file(self) -> None:
        with open(self.output_filename, "w") as f:
            f.write(HEADER)
            f.write("\n".join(self.output_lines))
            f.write("\n")

    def process(self) -> None:
        self._read_input_file()
        self._process_directives()
        self._extract_decls()
        self._generate_output()
        self._write_output_file()


@click.command()
@click.argument("source_file", type=click.Path())
@click.argument("output_file", type=click.Path())
@click.argument("compile_commands", type=click.Path())
@click.argument("version", type=click.Choice(["3.10", "3.12"]))
def main(
    source_file: str,
    output_file: str,
    compile_commands: str,
    version: str,
) -> None:
    def abspath(relpath: str) -> str:
        return os.path.abspath(os.path.join(os.getcwd(), relpath))

    source_file = abspath(source_file)
    output_file = abspath(output_file)
    compile_commands = abspath(compile_commands)

    print(f"Processing {source_file} -> {output_file}")
    print(f"Compile commands from: {compile_commands}")

    fp = FileParser(compile_commands)
    p = TemplateFileProcessor(source_file, output_file, fp, version)
    p.process()


if __name__ == "__main__":
    main()
