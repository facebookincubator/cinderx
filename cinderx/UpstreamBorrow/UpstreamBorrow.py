# Copyright (c) Meta Platforms, Inc. and affiliates.

# pyre-strict
import os
import re
from collections import defaultdict
from dataclasses import dataclass
from typing import Callable

import click

from clang.cindex import CursorKind

from .clang_parser import FileParser, ParsedFile

VERSION_AND_TRANSFORM = r"\s*(\[.*\])?\s*(:\S+)?"

BORROW_CPP_DIRECTIVES_PATTERN: re.Pattern[str] = re.compile(
    r".*// @Borrow CPP directives from (\S+)" + VERSION_AND_TRANSFORM
)
BORROW_CPP_DIRECTIVES_NOINCLUDE_PATTERN: re.Pattern[str] = re.compile(
    r".*// @Borrow CPP directives noinclude from (\S+)" + VERSION_AND_TRANSFORM
)
BORROW_DECL_PATTERN: re.Pattern[str] = re.compile(
    r"// @Borrow (function|typedef|var) (\S+) from (\S+)" + VERSION_AND_TRANSFORM
)
CPP_DIRECTIVE_PATTERN: re.Pattern[str] = re.compile(
    r"#\s*(define|undef|if|elif|else|endif|include)"
)

HEADER = """// Auto-generated by UpstreamBorrow.py.
// See the Buck target fbcode//cinderx/UpstreamBorrow:gen_borrowed.c.

"""


def extract_preprocessor_directives(
    parsed_file: ParsedFile, includes: bool = True
) -> list[str]:
    print(f"Extracting preprocessor directives from: {parsed_file.source_file}")

    directives = []
    continuation = False
    for line in parsed_file.lines:
        line = line.rstrip()
        if continuation:
            directives.append(line)
            continuation = line.endswith("\\")
        elif m := re.match(CPP_DIRECTIVE_PATTERN, line):
            if includes or not m.group(1) == "include":
                directives.append(line)
                continuation = line.endswith("\\")
            else:
                continuation = False
        else:
            continuation = False

    return directives


@dataclass
class Decl:
    kind: CursorKind
    name: str
    source_file: str
    version: str | None
    transform: str | None


@dataclass
class CppDirective:
    source_file: str
    includes: bool


def parse_borrow_info(input_string: str) -> Decl | None:
    match = BORROW_DECL_PATTERN.match(input_string)
    if not match:
        return None

    kind_str = match.group(1)
    name = match.group(2)
    source_file = match.group(3)
    version = match.group(4)  # not used for anything, but generated by callgraph.py
    transform = match.group(5)

    if kind_str == "function":
        # pyre-ignore[16]: `CursorKind` has no attribute `FUNCTION_DECL`.
        kind = CursorKind.FUNCTION_DECL
    elif kind_str == "typedef":
        # pyre-ignore[16]: `CursorKind` has no attribute `TYPEDEF_DECL`.
        kind = CursorKind.TYPEDEF_DECL
    elif kind_str == "var":
        # pyre-ignore[16]: `CursorKind` has no attribute `VAR_DECL`.
        kind = CursorKind.VAR_DECL
    elif kind_str == "enum":
        # pyre-ignore[16]: `CursorKind` has no attribute `ENUM_DECL`.
        kind = CursorKind.ENUM_DECL
    else:
        raise Exception(f"Unknown kind: {kind_str}")

    return Decl(kind, name, source_file, version, transform[1:] if transform else None)


def transform_eval_frame(lines: list[str]) -> list[str]:
    """Transforms a check to see if the eval_frame is overridden
    into one that accounts for the CinderX eval frame. The goal here is
    to have the specializer treat CinderX's frame evaluation function the
    same way it treats the default frame evaluation function."""
    return [
        line.replace(
            "_PyInterpreterState_GET()->eval_frame",
            "(_PyInterpreterState_GET()->eval_frame != NULL && _PyInterpreterState_GET()->eval_frame != Ci_EvalFrameFunc)",
        )
        for line in lines
    ]


TRANSFORMS: dict[str, Callable[[list[str]], list[str]]] = {
    "eval_frame_check": transform_eval_frame
}


class TemplateFileProcessor:
    input_filename: str
    output_filename: str
    file_parser: FileParser
    version: str
    input_lines: list[str | Decl | CppDirective]
    needed: dict[str, dict[CursorKind, set[str]]]
    decls: dict[str, dict[str, list[str]]]
    output_lines: list[str]

    def __init__(
        self,
        input_filename: str,
        output_filename: str,
        file_parser: FileParser,
        version: str,
    ) -> None:
        self.input_filename = input_filename
        self.output_filename = output_filename
        self.file_parser = file_parser
        self.version = version
        self.input_lines = []
        self.output_lines = []
        # pyre-ignore[8]: Incompatible attribute type
        self.needed = defaultdict(lambda: defaultdict(set))
        self.decls = defaultdict(dict)

    def _read_input_file(self) -> None:
        """Read the input file and parse borrow directives."""

        with open(self.input_filename, "r") as f:
            input_lines = f.readlines()

        for line in input_lines:
            line = line.rstrip()

            if match := parse_borrow_info(line):
                self.input_lines.append(match)

            elif match := BORROW_CPP_DIRECTIVES_PATTERN.match(line):
                source_file = match.group(1)
                d = CppDirective(source_file, includes=True)
                self.input_lines.append(d)

            elif match := BORROW_CPP_DIRECTIVES_NOINCLUDE_PATTERN.match(line):
                source_file = match.group(1)
                d = CppDirective(source_file, includes=False)
                self.input_lines.append(d)

            else:
                self.input_lines.append(line)

    def _process_directives(self) -> None:
        """Process borrow directives and group required actions."""
        for line in self.input_lines:
            match line:
                case Decl() as d:
                    self.needed[d.source_file][d.kind].add(d.name)
                case CppDirective() as d:
                    # We don't need to do anything here, we extract these in
                    # generate_output directly since they are done only once
                    # per file with all the directives extracted in a block.
                    pass
                case str():
                    # Catch malformed borrow directives
                    if line.startswith("// @Borrow"):
                        raise RuntimeError(f"@Borrow not processed: {line}")

    def _extract_decls(self) -> None:
        for source_file, needed_decls in self.needed.items():
            parsed_file = self.file_parser.parse(source_file)
            # We only need to look for symbols at top level.
            for cursor in parsed_file.translation_unit.cursor.get_children():
                # Skip definitions in #includes from the source_file
                if not cursor.extent.start.file.name.endswith(source_file):
                    continue

                name = cursor.spelling
                if name in needed_decls.get(cursor.kind, ()):
                    if extent := cursor.extent:
                        # We always extract complete lines
                        content = parsed_file.lines[
                            extent.start.line - 1 : extent.end.line
                        ]
                        # Overwrite earlier declarations; the last one is the
                        # function definition.
                        # pyre-fixme[6]: For 2nd argument expected `List[str]` but
                        #  got `str`.
                        self.decls[source_file][name] = content

    def _generate_output(self) -> None:
        out = []
        for line in self.input_lines:
            match line:
                case Decl(kind, name, source_file, _, transform):
                    lines = self.decls[source_file].get(name)
                    if lines is None:
                        print(f"Could not find {kind} for '{name}' in {source_file}")
                        continue
                    # Apply custom transformation if one exists for this function
                    if transform in TRANSFORMS:
                        lines = TRANSFORMS[transform](lines)
                    out.extend(lines)
                case CppDirective(source_file, includes):
                    parsed_file = self.file_parser.parse(source_file)
                    lines = extract_preprocessor_directives(parsed_file, includes)
                    out.extend(lines)
                case str():
                    out.append(line)
        self.output_lines = out

    def _write_output_file(self) -> None:
        with open(self.output_filename, "w") as f:
            f.write(HEADER)
            f.write("\n".join(self.output_lines))
            f.write("\n")

    def process(self) -> None:
        self._read_input_file()
        self._process_directives()
        self._extract_decls()
        self._generate_output()
        self._write_output_file()


@click.command()
@click.argument("source_file", type=click.Path())
@click.argument("output_file", type=click.Path())
@click.argument("compile_commands", type=click.Path())
@click.argument("version")
def main(
    source_file: str,
    output_file: str,
    compile_commands: str,
    version: str,
) -> None:
    def abspath(relpath: str) -> str:
        return os.path.abspath(os.path.join(os.getcwd(), relpath))

    source_file = abspath(source_file)
    output_file = abspath(output_file)
    compile_commands = abspath(compile_commands)

    print(f"Processing {source_file} -> {output_file}")
    print(f"Compile commands from: {compile_commands}")

    fp = FileParser(compile_commands)
    p = TemplateFileProcessor(source_file, output_file, fp, version)
    p.process()


if __name__ == "__main__":
    main()
