# Copyright (c) Meta Platforms, Inc. and affiliates.
# pyre-unsafe

from collections.abc import Awaitable, Callable, Generator
from types import ModuleType
from typing import Any, Mapping, NoReturn, TypeVar

class async_cached_classproperty:
    func: Any
    name: Any

    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def __get__(self, instance, owner) -> Any: ...

class async_cached_property:
    fget: Any
    func: Any
    name: Any
    slot: Any

    def __init__(self, *args, **kwargs) -> None: ...
    def __get__(self, instance, owner) -> Any: ...

class cached_classproperty:
    func: Any
    name: Any
    __name__: str

    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def __get__(self, instance, owner) -> Any: ...

class cached_property:
    fget: Any
    func: Any
    name: Any
    slot: Any
    __name__: str

    def __init__(self, *args, **kwargs) -> None: ...
    def clear(self, *args, **kwargs) -> Any: ...
    def has_value(self, *args, **kwargs) -> Any: ...
    def __get__(self, instance, owner) -> Any: ...
    def __set_name__(self, *args, **kwargs) -> Any: ...

class cached_property_with_descr(cached_property): ...

class _PatchEnabledDescr:
    def __get__(self, inst: StrictModule, typ: type[StrictModule]) -> bool: ...

_T = TypeVar("_T")
_TParams = TypeVar("_TParams")

class AsyncLazyValue(Awaitable[_T]):
    def __init__(
        self,
        # pyre-fixme[31]: Expression `typing.Callable[(_TParams,
        #  typing.Awaitable[_T])]` is not a valid type.
        coro_func: Callable[_TParams, Awaitable[_T]],
        # pyre-fixme[11]: Annotation `args` is not defined as a type.
        *args: _TParams.args,
        # pyre-fixme[11]: Annotation `kwargs` is not defined as a type.
        **kwargs: _TParams.kwargs,
    ) -> None: ...
    def __iter__(self) -> AsyncLazyValue[_T]: ...
    def __next__(self) -> NoReturn: ...
    def __await__(self) -> Generator[None, None, _T]: ...

class StrictModule(ModuleType):
    __name__: str
    __patch_enabled__: _PatchEnabledDescr

    def __init__(self, d: Mapping[str, object], enable_patching: bool) -> None: ...
    def patch(self, name: str, value: object) -> None: ...
    def patch_delete(self, name: str) -> None: ...

class StaticTypeError(TypeError): ...

def _compile_perf_trampoline_pre_fork() -> None: ...
def _get_entire_call_stack_as_qualnames_with_lineno() -> list[tuple[str, int]]: ...
def _get_entire_call_stack_as_qualnames_with_lineno_and_frame() -> list[
    tuple[str, int, object]
]: ...
def _is_compile_perf_trampoline_pre_fork_enabled() -> bool: ...
def anext(aiterator: object, default: object) -> object: ...
def clear_all_shadow_caches() -> None: ...
def clear_caches() -> None: ...
def clear_classloader_caches() -> None: ...
def delay_adaptive(delay: bool) -> None: ...
def disable_parallel_gc() -> None: ...
def enable_parallel_gc(min_generation: int = 2, num_threads: int = 0) -> None: ...
def freeze_type(o: object) -> object: ...
def get_adaptive_delay() -> int: ...
def get_parallel_gc_settings() -> dict[str, int] | None: ...
def get_threshold() -> tuple[int, int, int]: ...
def has_parallel_gc() -> bool: ...
def immortalize_heap() -> None: ...
def is_immortal(o: object) -> bool: ...
def set_adaptive_delay(delay: int) -> None: ...
def strict_module_patch(name: str, value: object) -> None: ...
def strict_module_patch_delete(name: str) -> None: ...
def strict_module_patch_enabled(mod: object) -> bool: ...
def watch_sys_modules() -> None: ...
